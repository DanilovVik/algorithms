## 数字格式转换问题

### 罗马数字 - 阿拉伯数字相互转换

#### 罗马数字的特点

1. 罗马数字共有7个，即I（1）、V（5）、X（10）、L（50）、C（100）、D（500）和M（1000）
2. 重复数次：一个罗马数字重复几次，就表示这个数的几倍
3. 同一数码最多只能连续出现三次，如`40`不可表示为`XXXX`，而要表示为`XL`
4. 右加左减：
  - 在较大的罗马数字的右边记上较小的罗马数字，表示大数字加小数字
  - 在较大的罗马数字的左边记上较小的罗马数字，表示大数字减小数字
  - 左减的数字有限制，仅限于`I`、`X`、`C`。比如`45`不可以写成`VL`，只能是`XLV`
  - 但是，左减时不可跨越一个位值。比如，`99`不可以用`IC`表示，而是用`XCIX`表示
  - **左减数字最多为一位**，比如`8`写成`VIII`，而非`IIX`
  - **右加数字不可连续超过三位**，比如`14`写成`XIV`，而非`XIIII`

#### [阿拉伯数字 -> 罗马数字](./number-to-roma.js)

罗马数字每三组字母是一个权位范围，例如，`I, V, X`可代表`[1, 10]`内数字，`X, L, C`可代表`[10, 100]`内数字，`C, D, M`可代表`[100, 1000]`范围数字。对于`1000`以上，暂且只增加`M`个数。由此可得规律。

以`1994`为例：

0. 设置`num = 1994`，基准数`base = 10`
1. 获取余数`remainder = num % base = 1994 % 10 = 4`，即一个小节，转换该小节：
  - 因为`4 < 5 && 4 > 3`，因此返回`IV`
2. 更新`num = num - remainder = 1994 - 4 = 1990`，更新`base = base * 10 = 100`
3. 获取余数`remainder = num % base = 1990 % 100 = 90`，即一个小节，转换该小节：
  - 因为`90 > 50 && 90 < 100`，因此返回`XC`
4. 更新`num = num - remainder = 1990 - 90 = 1900`，更新`base = base * 10 = 1000`
5. 获取余数`remainder = num % base = 1900 % 1000 = 900`，即一个小节，转换该小节：
  - 因为`900 > 500 && 900 < 1000`，因此返回`CM`
6. 更新`num = num - remainder = 1900 - 900 = 1000`，更新`base = base * 10 = 10000`
7. 获取余数`remainder = num % base = 1000 % 10000 = 1000`，即一个小节，转换该小节：
  - 因为`1000 >= 1000`，因此返回`M`
8. 更新`num = num - remainder = 1000 - 1000 = 0`，结束遍历
9. 合并小节的返回值得到结果`MCMXCIV`

#### [罗马数字 -> 阿拉伯数字](./roma-to-numbers.js)

从右到左依次遍历罗马字符。根据规则 4，如果当前字符代表的数字，小于右侧字符代表的数字，则应做减法；否则做加法。

以`MCMXCIV`为例：

0. 设置`roma = MCMXCIV`，`result = 0`，从最后一位`i = roma.length - 1`开始遍历
1. `i = 0`时，`roma[i] === V`，数字 5 大于右侧数字（超范围），累加`result += 5`
2. `i = 1`时，`roma[i] === I`，数字 1 小于右侧数字 5，累减`result -= 1`
3. `i = 2`时，`roma[i] === C`，数字 100 大于右侧数字 1，累加`result += 100`
4. `i = 3`时，`roma[i] === X`，数字 10 小于右侧数字 100，累减`result -= 10`
5. `i = 4`时，`roma[i] === M`，数字 1000 大于右侧数字 10，累加`result += 1000`
6. `i = 5`时，`roma[i] === C`，数字 100 小于右侧数字 1000，累减`result -= 100`
7. `i = 6`时，`roma[i] === M`，数字 1000 大于右侧数字 100，累加`result += 1000`
8. 遍历完成，返回结果`1994`

### 中文数字 - 阿拉伯数字相互转换

#### 中文数字的特点

1. 中文数字的权位和小节
  - 以一万，即 10000 为小节，每小节拥有一个权位，权位最低为`万`，依次是`万`，`亿`，`万亿`。`万`以下的小节没有权位。例如，
    - 数字`20002020200`每四个为一个小节，分为`200 0202 0200`，中文为`二百亿零二百零二万零二百`
    - 数字`20001234`分为`2000 1234`，中文为`二千万一千二百三十四`
  - 小节内部，拥有`十`、`百`、`千`的权位。例如，数字`1111`本身是一个小节，中文为`一千一百一十一`
  - 小节内部的`十`、`百`、`千`不能连续出现，但内部权位可以和外部的`万`等权位连续出现。例如，`二十万`

2. 中文数字内的零
  - 10000 为小节，小节结尾即便是`0`，也不使用`零`。例如：`1000`是`一千`
  - **小节内部**，两个非零数字之间如果有 0，合并时要使用`零`。例如，`1070`是`一千零七十`
  - 当小节的`千`位是 0 时，若本小节的左侧一小节无其他数字，则不用`零`，否则就要用`零`。例如，`10700`是`一万零七百`，而`0100`则是`一百`

#### [阿拉伯数字 -> 中文数字](./number-to-chinese.js)

以`20002020202`为例，遍历，分割成各个小节进行处理：

0. 设置`num = 20002020202`
1. 获取第一个小节，为`section = num % 10000 = 202`，补齐为`0202`
  - 处理小节内部，从左边第一位开始遍历；
  - `i = 0`时，`section[i] === 0`：跳过
  - `i = 1`时，`section[i] === 2`：此时为百位，获取到匹配为`二百`
  - `i = 2`时，`section[i] === 0`：跳过
  - `i = 3`时，`section[i] === 2`：此时为个位，且根据规则 - 两个非零数字之间如果有 0，合并时要使用`零`，获取到匹配为`零二`
  - 小节内部处理完成，返回`二百零二`
  - 获取该小节权位，为空字符串，则值不变，还是`二百零二`
  - 因为该小节千位是`0`，且下一小节不是空，因此补零为`零二百零二`
2. 获取第二个小节，为`section = num % 10000 = 200`，补齐为`0202`
  - 因为值和上一个小节一样，不再解释，返回`二百零二`
  - 获取该小节权位，为`万`，则为`二百零二万`
  - 因为该小节千位是`0`，且下一小节不是空，因此补零为`零二百零二万`
3. 获取第三个小节，为`section = num % 10000 = 200`
  - 处理小节内部，返回`二百`
  - 获取该小节权位，为`亿`，则为`二百亿`
5. 合并前面的处理，得到`二百亿零二百零二万零二百零二`

#### [中文数字 -> 阿拉伯数字](./chinese-to-number.js)

中文数字转阿拉伯数字比较简单。遍历到权位之后进位即可。以`二百亿零二百零二万零二百零二`为例：

0. 设置`chinese = 二百亿零二百零二万零二百零二`，结果`result = 0`，小节值的缓存栈`tmp = []`，然后从左侧`i = 0`开始遍历
1. `i = 0`，`chinese[i] === 二`，进入缓存栈`tmp.push(2)`，此时`tmp`内为`[2]`
2. `i = 1`，`chinese[i] === 百`，则从栈中取出顶位数字，进位后入栈`tmp.push(tmp.pop() * 100)`，此时`tmp`内为`[200]`
3. `i = 2`，`chinese[i] === 亿`，则栈内数字累加后，乘以该小节权位，叠加到`result`：`result += tmp.reduce((n1, n2) => n1 + n2, 0) * 100000000`，栈清空`tmp = []`
4. `i = 3`，`chinese[i] === 零`，跳过
5. `i = 4`，`chinese[i] === 二`，进入缓存栈`tmp.push(2)`，此时`tmp`内为`[2]`
6. `i = 5`，`chinese[i] === 百`，则从栈中取出顶位数字，进位后入栈`tmp.push(tmp.pop() * 100)`，此时`tmp`内为`[200]`
7. `i = 6`，`chinese[i] === 零`，跳过
8. `i = 7`，`chinese[i] === 二`，进入缓存栈`tmp.push(2)`，此时`tmp`内为`[200, 2]`
9. `i = 8`，`chinese[i] === 万`，则栈内数字累加后，乘以该小节权位，叠加到`result`：`result += tmp.reduce((n1, n2) => n1 + n2, 0) * 100000000`，栈清空`tmp = []`
10. `i = 9`，`chinese[i] === 零`，跳过
11. `i = 10`，`chinese[i] === 二`，进入缓存栈`tmp.push(2)`，此时`tmp`内为`[2]`
12. `i = 11`，`chinese[i] === 百`，则从栈中取出顶位数字，进位后入栈`tmp.push(tmp.pop() * 100)`，此时`tmp`内为`[200]`
13. `i = 12`，`chinese[i] === 零`，跳过
14. `i = 13`，`chinese[i] === 二`，进入缓存栈`tmp.push(2)`，此时`tmp`内为`[200, 2]`
15. 遍历完成，返回`result + tmp.reduce((n1, n2) => n1 + n2, 0)`即最终结果`20002020202`
